use serde_json::Value;

use yew::prelude::*;

use crate::props::FieldStdProps;
use crate::widget::form::ValidateFn;

use super::context::{FormContext, FormObserver, FieldHandle, FieldOptions};

/// Text field state handling.
pub struct FieldState {
    real_validate: ValidateFn<Value>,
    form_ctx: Option<FormContext>,
    field_handle: Option<FieldHandle>,
    _form_ctx_handle: Option<ContextHandle<FormContext>>,
    _form_ctx_observer: Option<FormObserver>,
    on_form_data_change: Callback<FormContext>,
    on_change: Option<Callback<Value>>,

    // local state, usage depends whether we have a name/form_ctx
    // None => store checked state locally
    // Some => use it to track/detect changes
    value: Value,
    valid: Result<(), String>,
}

/// Messages generated by [FieldState].
///
/// Should be passed to [ FieldState::update_hook] from [Component::update].
pub enum FieldStateMsg {
    FormCtxUpdate(FormContext), // FormContext object changed
    FormCtxDataChange, // Data inside FormContext changed
}

impl FieldState {

    /// Create a new instance.
    ///
    /// Setup form context interaction if the field has a name.
    ///
    /// Make sure you call [Self::update_hook] from [Component::update].
    pub fn create<COMP: Component>(
        ctx: &Context<COMP>,
        props: &FieldStdProps,
        on_state_change: Callback<FieldStateMsg>,
        on_change: Option<Callback<Value>>,
        real_validate: ValidateFn<Value>,
    ) -> FieldState {

        let on_form_ctx_change = Callback::from({
            let on_state_change = on_state_change.clone();
            move |form_ctx: FormContext| {
                on_state_change.emit(FieldStateMsg::FormCtxUpdate(form_ctx));
            }
        });

        let on_form_data_change = Callback::from({
            let on_state_change = on_state_change.clone();
            move |_form_ctx: FormContext| {
                on_state_change.emit(FieldStateMsg::FormCtxDataChange);
            }
        });

        let mut state = Self {
            value: Value::Null,
            valid: Ok(()),
            real_validate,
            form_ctx: None,
            field_handle: None,
            _form_ctx_handle: None,
            _form_ctx_observer: None,
            on_form_data_change: on_form_data_change.clone(),
            on_change,
        };


        if props.name.is_some() {
            if let Some((form, handle)) = ctx.link().context::<FormContext>(on_form_ctx_change) {
                state._form_ctx_handle = Some(handle);
                state._form_ctx_observer = Some(form.add_listener(on_form_data_change));
                state.form_ctx = Some(form);
            }
        }

        state
    }

    /// Get current field value and validation result.
    pub fn get_field_data(&self) -> (Value, Result<(), String>) {
        if let Some(field_handle) = &self.field_handle {
            field_handle.get_data()
        } else {
            (self.value.clone(), self.valid.clone())
        }
    }

    /// Force value - for fields without name (no FormContext)
    pub fn force_value(
        &mut self,
        value: impl Into<Value>,
        valid: Option<Result<(), String>>,
    ) {
        let value = value.into();
        self.valid = valid.unwrap_or_else(|| {
            self.real_validate.validate(&value)
                .map_err(|e| e.to_string())
        });
        self.value = value;
    }

    /// Set the field value
    pub fn set_value(&mut self, value: impl Into<Value>) {

        self.value = value.into();
        self.valid = self.real_validate.validate(&self.value)
            .map_err(|e| e.to_string());

        if let Some(field_handle) = &mut self.field_handle {
            field_handle.set_value(self.value.clone());
        }

        if let Some(on_change) = &self.on_change {
            on_change.emit(self.value.clone());
        }
    }

    /// Set the field default value
    pub fn set_default(&mut self, default: impl Into<Value>) {
        if let Some(field_handle) = &mut self.field_handle {
            field_handle.set_default(default.into());
        }
    }

    /// Trigger re-validation
    pub fn validate(&mut self) {
        self.valid = self.real_validate.validate(&self.value)
            .map_err(|e| e.to_string());

        if let Some(field_handle) = &mut self.field_handle {
            field_handle.validate();
        }
    }

    /// Register the field inm the FormContext
    pub fn register_field(
        &mut self,
        props: &FieldStdProps,
        value: impl Into<Value>,
        default: impl Into<Value>,
        radio_group: bool,
    ) {
        let name = match &props.name {
            Some(name) => name,
            None => {
                self.field_handle = None;
                return;
            }
        };

        let form_ctx = match &self.form_ctx {
            Some(form_ctx) => form_ctx.clone(),
            None => {
                self.field_handle = None;
                return;
            }
        };

        let options = FieldOptions {
            submit: props.submit,
            submit_empty: props.submit_empty,
            disabled: props.disabled,
            required: props.required,
        };

        let field_handle = form_ctx.register_field(
            name,
            value.into(),
            default.into(),
            radio_group,
            Some(self.real_validate.clone()),
            options,
        );

        self.field_handle = Some(field_handle);
    }

    pub fn update_field_options(
        &mut self,
        props: &FieldStdProps,
    ) {
        if let Some(field_handle) = &mut self.field_handle {
            let options = FieldOptions {
                submit: props.submit,
                submit_empty: props.submit_empty,
                disabled: props.disabled,
                required: props.required,
            };
            field_handle.update_field_options(options);
        }
    }

    pub fn update_hook(
        &mut self,
        props: &FieldStdProps,
        msg: FieldStateMsg,
        default: impl Into<Value>,
        radio_group: bool,
    ) -> bool {
        match msg {
            FieldStateMsg::FormCtxUpdate(form_ctx) => {
                self._form_ctx_observer = Some(form_ctx.add_listener(self.on_form_data_change.clone()));
                self.form_ctx = Some(form_ctx);
                self.register_field(props, self.value.clone(), default, radio_group);
                true
            }
            FieldStateMsg::FormCtxDataChange => {
                if self.field_handle.is_some() {
                    let (value, valid) = self.get_field_data();
                    let value_changed = value != self.value;
                    let valid_changed = valid != self.valid;
                    self.value = value;
                    self.valid = valid;

                    if value_changed {
                        if let Some(on_change) = &self.on_change {
                            on_change.emit(self.value.clone());
                        }
                    }

                    return value_changed || valid_changed;
                }
                false
            }
        }
    }
}

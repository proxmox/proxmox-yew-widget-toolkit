use serde_json::Value;

use yew::prelude::*;

use crate::props::FieldStdProps;
use crate::widget::form::ValidateFn;

use super::{FieldHandle, FormContext, FormObserver};

/// Text field state handling.
pub(crate) struct TextFieldState {
    value: String,
    valid: Result<(), String>,
    real_validate: ValidateFn<Value>,
    form_ctx: Option<FormContext>,
    field_handle: Option<FieldHandle>,
    _form_ctx_handle: Option<ContextHandle<FormContext>>,
    _form_ctx_observer: Option<FormObserver>,
    on_form_data_change: Callback<FormContext>,
    on_change: Option<Callback<String>>,
}

/// Messages generated by [TextFieldState].
///
/// Should be passed to [ TextFieldState::update_hook] from [Component::update].
pub enum TextFieldStateMsg {
    FormCtxUpdate(FormContext), // FormContext object changed
    FormCtxDataChange, // Data inside FormContext changed
}

impl TextFieldState {

    /// Create a new instance.
    ///
    /// Setup form context interaction if the field has a name.
    ///
    /// Make sure you call [Self::update_hook] from [Component::update].
    pub fn create<COMP: Component>(
        ctx: &Context<COMP>,
        props: &FieldStdProps,
        on_state_change: Callback<TextFieldStateMsg>,
        on_change: Option<Callback<String>>,
        real_validate: ValidateFn<Value>,
    ) -> TextFieldState {

        let on_form_ctx_change = Callback::from({
            let on_state_change = on_state_change.clone();
            move |form_ctx: FormContext| {
                on_state_change.emit(TextFieldStateMsg::FormCtxUpdate(form_ctx));
            }
        });

        let on_form_data_change = Callback::from({
            let on_state_change = on_state_change.clone();
            move |_form_ctx: FormContext| {
                on_state_change.emit(TextFieldStateMsg::FormCtxDataChange);
            }
        });

        let mut state = Self {
            value: String::new(),
            valid: Ok(()),
            real_validate,
            form_ctx: None,
            field_handle: None,
            _form_ctx_handle: None,
            _form_ctx_observer: None,
            on_form_data_change: on_form_data_change.clone(),
            on_change,
        };


        if props.name.is_some() {
            if let Some((form, handle)) = ctx.link().context::<FormContext>(on_form_ctx_change) {
                state._form_ctx_handle = Some(handle);
                state._form_ctx_observer = Some(form.add_listener(on_form_data_change));
                state.form_ctx = Some(form);
            }
        }

        state
    }

    /// Get current field value and validation result.
    pub fn get_field_data(&self) -> (String, Result<(), String>) {
        if let Some(field_handle) = &self.field_handle {
            let value = field_handle.get_text();
            let valid = field_handle.get_valid();
            (value, valid)
        } else {
            (self.value.clone(), self.valid.clone())
        }
    }

    /// Force value - for fields without name (no FormContext)
    pub fn force_value(
        &mut self,
        value: String,
        valid: Option<Result<(), String>>,
    ) {
        self.valid = valid.unwrap_or_else(|| {
            self.real_validate.validate(&value.clone().into())
                .map_err(|e| e.to_string())
        });
        self.value = value;
    }

    /// Set the field value
    pub fn set_value(&mut self, value: String) {
        if let Some(field_handle) = &mut self.field_handle {
            field_handle.set_value(value.clone().into());
        } else {
            self.value = value.clone();
            self.valid = self.real_validate.validate(&value.clone().into())
                .map_err(|e| e.to_string());
        }
    }

    /// Register the field inm the FormContext
    pub fn register_field(&mut self, props: &FieldStdProps, value: String, default: String) {
        let name = match &props.name {
            Some(name) => name,
            None => {
                self.field_handle = None;
                return;
            }
        };

        let form_ctx = match &self.form_ctx {
            Some(form_ctx) => form_ctx.clone(),
            None => {
                self.field_handle = None;
                return;
            }
        };

        let field_handle = form_ctx.register_field(
            name,
            value.into(),
            default.into(),
            Some(self.real_validate.clone()),
            props.submit,
            props.submit_empty,
        );

        self.field_handle = Some(field_handle);
    }

    pub fn update_hook(&mut self, props: &FieldStdProps, msg: TextFieldStateMsg, default: String) -> bool {
        match msg {
            TextFieldStateMsg::FormCtxUpdate(form_ctx) => {
                self._form_ctx_observer = Some(form_ctx.add_listener(self.on_form_data_change.clone()));
                self.form_ctx = Some(form_ctx);
                self.register_field(props, self.value.clone(), default);
                true
            }
            TextFieldStateMsg::FormCtxDataChange => {
                if let Some(field_handle) = &self.field_handle {

                    let (value, valid) = self.get_field_data();
                    let value_changed = value != self.value;
                    let valid_changed = valid != self.valid;
                    self.value = value;
                    self.valid = valid;

                    if value_changed {
                        if let Some(on_change) = &self.on_change {
                            on_change.emit(self.value.clone());
                        }
                    }

                    return value_changed || valid_changed;
                }
                false
            }
        }
    }
}
